Welcome to OpenRelativity! This project is a spin-off from the MIT Game Lab's game A Slower Speed of Light.

OpenRelativity is a set of tools for simulating the effects of traveling near the speed of light in the Unity3D game engine. We are producing this simple engine in the hopes that more developers or educators can use our toolset to produce more simulations or explorations of travel near the speed of light.

Within this readme is a quick overview of each piece of code that we have put into this project, along with a very quick description of how to use the toolset to make sure your project follows the rules of relativity. We hope you can use this toolset to produce something amazing, and if you find bugs or have an improvement to make to the code base, feel free to help turn OpenRelativity into an even better project.


How to use OpenRelativity:

With our code base, there are a few simple rules around how to get an object into the Unity environment and have it work with our tools. We will start with the basics of the scene, then the player object itself, and then other objects throughout the scene.

General Notes on Relativity and the Limitations of our Code:

While we have tried to produce a physically accurate representation of special relativity, there are some unfortunate limitations to our code, and they are as follows

1. Only the player object may move freely. All other objects must either have a constant velocity originating at infinity and ending at infinity, or else be still.

2. The Player's speed must never reach or exceed the speed of light.

3. Due to constraint one, the other objects in the scene cannot travel in any direction but a straight line. 

4. Because we did not write a new lighting system, all shadows must be permanent. That is, any shadow that is present on an object must be part of its texture and assumed to never change. DO NOT use the built in Unity lighting system with baked shadows unless no objects in the scene will ever disappear. Lighting and shadows are an extremely complicated field of special relativity, and they are not supported at this time. 


The Scene:
We have set up this project with a few basic settings that are meant to make our code base work smoothly. First, under Render Settings, we have the skybox's shader. This shader is slightly different from the one on every other object, and it also determines the basic texture of the sky. We do not work with anything other than solid colors, but if you would like to experiment with a more interesting texture on the skybox, feel free to do so. Next, under the Project Settings/Tags, we have a custom tag of "Playermesh" and a custom layer "Player." The Playermesh tag is used to access the top level player object, which contains the player's mesh and physical information. The Player layer is used to denote which objects should collide with the player. We currently have the Project Settings/Physics collision layers set up so that objects collide only with objects denoted "Player" and not with other objects in the scene. There is one exception to this, in the Receiver object, but that will be covered later. Apart from this, the scene is as it should be normally.

The Player:

The player is already set up with our movement code, game state code, and a quick script that puts the speed of light and player speed on the screen. It is set up as a nested object. The player mesh is the parent object, which has the physical aspects of the player. It has a mesh renderer, a collider, and a rigidbody. Each of these components is necessary for our code base. Any of these attributes can be modified, but if the rigidbody's drag, gravity, or frozen rotation settings are changed, the project will no longer adhere to the rules of special relativity and it may react unpredictably with our code, so please don't change these settings unless you know what you're doing. If you wish to change the player's mesh, that won't cause any problems, but keep in mind that this framework was meant to provide a first-person view of relativity, and anything but a first person view will no longer be physically accurate.

At the second level, we have the Player gameobject, which is where we keep the code. There are three pieces of code on the player character. Movement Scripts takes care of the player's movement, the camera's movement, and the change in the speed of light by user input. Game State keeps track of many important variables for the relativistic effects, and controls pausing and ending the game.

Finally, we have the camera. The camera does not have any scripts on it, but is affected by Movement Scripts and must be attached to the player or else the perspective will be off.

Other Objects and adding them to the scene:

By a few simple steps, any object can be added to the scene of Open Relativity. These steps mostly consist of adding the following components to your new object.

The object must have a Mesh Filter with a mesh attached to it. Any mesh will do, regardless of complexity.

The object must have a Collider attached to it. Box Colliders work great and are the simplest. Mesh colliders will most likely not work well, and they will definitely not conform to the Lorenz contraction because we do that in the graphics card, not in scripts.

The object must have a Mesh Renderer. As in constraint four, we do not have a lighting system, so it is best if you uncheck "cast shadows" and "receive shadows" in the Mesh Renderer. Any materials that are a part of the Mesh Renderer must use the ColorShift shader. Note that they do not need to use the relativity materials that are in the project, but they do need to have the ColorShift shader (the Relativity/ColorShift option in the Shader drop down menu) in order to function properly.

The object must have a rigidbody with gravity unchecked, 100 mass and infinite drag. 

Finally, the object must have the script "RelativisticObject" attached to it. If the objects VIW (Velocity In World) is set to anything but (0,0,0), it will move constantly while the scene is playing.

With these components added to your new object, they will deform and change color according to the rules of special relativity. That's all it takes!




CODE AND PREFAB ASSETS INCLUDED IN OPEN RELATIVITY

This section details the uses of each object in the Open Relativity Unity project. Each piece will have an overview of its function, but line by line comments exist in the code pieces themselves.

Index
	Code:

	1. Relativistic Object
	2. Movement Scripts
	3. Info Script
	4. Game State	
	5. Object Mesh Density
	6. Relativity Shader
	7. Skybox Shader	
	8. Receiver and Receiver2 Script
	9. Sender Script

	Prefabs:
	
	1. Receiver
	2. Sender
	3. Moving Person

	Materials and Textures




1. Relativistic Object

	Relativistic Object is the base code for all the non-player objects in the scene. Combined with the Relativity shader, it keeps track of relatvistic effects,moves the object if needed, and performs necessary actions for the shader to work. It first forces the object to have a unique material, so that the object's shader uses variables specific to that object, and not across all objects using the relativity shader (which is what would happen if we did nothing). It also keeps track of when the object was created and when it is supposed to disappear, so that the time-distorting effects of special relativity do not accidentally force the object to appear before its start location or after its disappearance. 

2. Movement Scripts

	Movement Scripts is what takes player input for the mouse and keyboard and moves the player accordingly. This code covers player movement, camera movement, and change in the speed of light. The movement follows a formula for relativistic velocity addition, which is included in the comments before the movement code. It is also currently set for free movement in three dimensions. If you wish to constrain the player to a flat ground plane (the X-Z plane, in Unity) then there are a couple lines of code that are marked for easy change. 

3. Info Script

	This just displays the two text boxes in the upper left hand corner, using info from Game State.

4. Game State

	Game State is the brain of the Open Relativity code. It stores important variables for relativistic effects and keeps track of changes in the player's status. Relativistic Object and Movement Scripts rely on being able to find Game State and access its information. It also keeps track of the pause state of the game, letting all other objects query game state rather than keeping track of it themselves.

5. Object Mesh Density

	Object Mesh density takes a constant value (named constant). It searches over the triangles on the mesh of the object that it is attached to. If it finds a triangle with area greater than the constant value, it splits that triangle into four smaller triangles, in a way that still works effectively with the relativistic code. The reason for this code is that the lorenz contraction looks better with a higher concentration of vertices (since it is a vertex shader).

6. Relativity Shader

	This shader implements a vertex shader that runs the Lorenz contraction, and a fragment shader that implements the relativistic doppler shift. 

7. Skybox Shader
	
	This shader implements relativistic doppler shift on the skybox, because the lorenz contraction does not look good on the very low-vertex skybox.

8. Receiver and Receiver2 Script
	
	